#include "catch2/catch.hpp"
#include <ert/res_util/matrix.hpp>
#include <ert/res_util/matrix_lapack.hpp>

/**
 * Results generated by this equivalent implementation in numpy.
 * This form is often used in data assimilation literature.
 *
 * import numpy as np
 *
 * nrow = 4
 * ncol = 2
 *
 * X = 10 * np.ones((nrow, ncol))
 * X[0, 0] = 20;
 * X[1, 1] = 30;
 * X[2, 0] = 45;
 * X[3, 1] = 1.5
 *
 * # Each row has originally non-zero mean
 * X.mean(axis = 1)
 *
 * I_N = np.identity(ncol)
 * One = np.ones((ncol, 1))
 * A = X @ (I_N - One @ One.T / ncol)
 *
 * # Each row has zero mean after transformation
 * A.mean(axis = 1)
 *
 */

matrix_type *test_matrix() {
    const int nrow = 4;
    const int ncol = 2;

    matrix_type *X = matrix_alloc(nrow, ncol);
    matrix_iset(X, 0, 0, 20.0);
    matrix_iset(X, 1, 0, 10.0);
    matrix_iset(X, 2, 0, 45.0);
    matrix_iset(X, 3, 0, 10.0);
    matrix_iset(X, 0, 1, 10.0);
    matrix_iset(X, 1, 1, 30.0);
    matrix_iset(X, 2, 1, 10.0);
    matrix_iset(X, 3, 1, 1.5);

    return X;
}

TEST_CASE("matrix_subtract_row_mean", "[res_util]") {

    matrix_type *X = test_matrix();

    matrix_subtract_row_mean(X);

    double *result = X->data;

    // row 0
    REQUIRE(result[0] == 5.0);
    REQUIRE(result[4] == -5.0);
    // row 1
    REQUIRE(result[1] == -10.0);
    REQUIRE(result[5] == 10.0);
    // row 2
    REQUIRE(result[2] == 17.5);
    REQUIRE(result[6] == -17.5);
    // row 3
    REQUIRE(result[3] == 4.25);
    REQUIRE(result[7] == -4.25);

    matrix_free(X);
}

SCENARIO("Solving a linear equation with dgesvx") {
    GIVEN("A diagonal matrix A") {
        int N = 4;
        matrix_type *A = matrix_alloc(N, N);
        for (int i = 0; i < N; i++)
            matrix_iset(A, i, i, 1.0 / (i + 1));

        AND_GIVEN("A vector b") {
            matrix_type *bx = matrix_alloc(N, 1);
            for (int i = 0; i < N; i++)
                matrix_iset(bx, i, 0, 1);

            WHEN("Using dgesvx to solve the linear equation Ax=b") {
                double rcond_value;
                double *rcond = GENERATE_REF(&rcond_value, nullptr);
                matrix_dgesvx(A, bx, rcond);

                THEN("b is modified to be the solution x") {
                    for (int i = 0; i < N; i++)
                        REQUIRE(matrix_iget(bx, i, 0) == (i + 1));
                }
            }
            matrix_free(bx);
        }
        matrix_free(A);
    }
}
